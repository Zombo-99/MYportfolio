{"id":"Mqgl","dependencies":[{"name":"/home/moh/Desktop/MYPortfolio/package.json","includedInParent":true,"mtime":1725356897845},{"name":"/home/moh/Desktop/MYPortfolio/node_modules/three-stdlib/package.json","includedInParent":true,"mtime":1724625312988},{"name":"three","loc":{"line":1,"column":33,"index":33},"parent":"/home/moh/Desktop/MYPortfolio/node_modules/three-stdlib/shaders/SSRShader.js","resolved":"/home/moh/Desktop/MYPortfolio/node_modules/three/build/three.module.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.SSRShader=exports.SSRDepthShader=exports.SSRBlurShader=void 0;var t=require(\"three\");const e=exports.SSRShader={defines:{MAX_STEP:0,isPerspectiveCamera:!0,isDistanceAttenuation:!0,isFresnel:!0,isInfiniteThick:!1,isSelective:!1},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new t.Vector2},cameraProjectionMatrix:{value:new t.Matrix4},cameraInverseProjectionMatrix:{value:new t.Matrix4},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},surfDist:{value:.007},thickTolerance:{value:.03}},vertexShader:\"\\n\\n    varying vec2 vUv;\\n\\n    void main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n    }\\n\\n  \",fragmentShader:\"\\n\\t\\t// precision highp float;\\n\\t\\tprecision highp sampler2D;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform sampler2D tNormal;\\n\\t\\tuniform sampler2D tMetalness;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform float cameraRange;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float cameraNear;\\n\\t\\tuniform float cameraFar;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float surfDist;\\n\\t\\tuniform mat4 cameraProjectionMatrix;\\n\\t\\tuniform mat4 cameraInverseProjectionMatrix;\\n\\t\\tuniform float thickTolerance;\\n\\t\\t#include <packing>\\n\\t\\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\\n\\t\\t\\t//x0: point, x1: linePointA, x2: linePointB\\n\\t\\t\\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\\n\\t\\t\\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\\n\\t\\t}\\n\\t\\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\\n\\t\\t\\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\\n\\t\\t\\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\\n\\t\\t\\t//// http://paulbourke.net/geometry/pointlineplane/\\n\\t\\t\\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\\n\\t\\t\\tfloat x0=point.x,y0=point.y,z0=point.z;\\n\\t\\t\\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\\n\\t\\t\\tfloat d=-(a*x+b*y+c*z);\\n\\t\\t\\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\\n\\t\\t\\treturn distance;\\n\\t\\t}\\n\\t\\tfloat getDepth( const in vec2 uv ) {\\n\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\t\\t}\\n\\t\\tfloat getViewZ( const in float depth ) {\\n\\t\\t\\t#ifdef isPerspectiveCamera\\n\\t\\t\\t\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\n\\t\\t\\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\n\\t\\t\\tclipPosition *= clipW; //clip\\n\\t\\t\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\\n\\t\\t}\\n\\t\\tvec3 getViewNormal( const in vec2 uv ) {\\n\\t\\t\\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\\n\\t\\t}\\n\\t\\tvec2 viewPositionToXY(vec3 viewPosition){\\n\\t\\t\\tvec2 xy;\\n\\t\\t\\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\\n\\t\\t\\txy=clip.xy;//clip\\n\\t\\t\\tfloat clipW=clip.w;\\n\\t\\t\\txy/=clipW;//NDC\\n\\t\\t\\txy=(xy+1.)/2.;//uv\\n\\t\\t\\txy*=resolution;//screen\\n\\t\\t\\treturn xy;\\n\\t\\t}\\n\\t\\tvoid main(){\\n\\t\\t\\t#ifdef isSelective\\n\\t\\t\\t\\tfloat metalness=texture2D(tMetalness,vUv).r;\\n\\t\\t\\t\\tif(metalness==0.) return;\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat depth = getDepth( vUv );\\n\\t\\t\\tfloat viewZ = getViewZ( depth );\\n\\t\\t\\tif(-viewZ>=cameraFar) return;\\n\\n\\t\\t\\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\\n\\t\\t\\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\\n\\n\\t\\t\\tvec2 d0=gl_FragCoord.xy;\\n\\t\\t\\tvec2 d1;\\n\\n\\t\\t\\tvec3 viewNormal=getViewNormal( vUv );\\n\\n\\t\\t\\t#ifdef isPerspectiveCamera\\n\\t\\t\\t\\tvec3 viewIncidenceDir=normalize(viewPosition);\\n\\t\\t\\t\\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec3 viewIncidenceDir=vec3(0,0,-1);\\n\\t\\t\\t\\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\\n\\t\\t\\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\\n\\t\\t\\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\\n\\t\\t\\t// maxDistance/maxReflectRayLen=cos(theta)\\n\\t\\t\\t// maxDistance/maxReflectRayLen==dot(a,b)\\n\\t\\t\\t// maxReflectRayLen==maxDistance/dot(a,b)\\n\\n\\t\\t\\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\\n\\t\\t\\t#ifdef isPerspectiveCamera\\n\\t\\t\\t\\tif(d1viewPosition.z>-cameraNear){\\n\\t\\t\\t\\t\\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\\n\\t\\t\\t\\t\\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\\n\\t\\t\\t\\t\\td1viewPosition=viewPosition+viewReflectDir*t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t#endif\\n\\t\\t\\td1=viewPositionToXY(d1viewPosition);\\n\\n\\t\\t\\tfloat totalLen=length(d1-d0);\\n\\t\\t\\tfloat xLen=d1.x-d0.x;\\n\\t\\t\\tfloat yLen=d1.y-d0.y;\\n\\t\\t\\tfloat totalStep=max(abs(xLen),abs(yLen));\\n\\t\\t\\tfloat xSpan=xLen/totalStep;\\n\\t\\t\\tfloat ySpan=yLen/totalStep;\\n\\t\\t\\tfor(float i=0.;i<MAX_STEP;i++){\\n\\t\\t\\t\\tif(i>=totalStep) break;\\n\\t\\t\\t\\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\\n\\t\\t\\t\\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\\n\\t\\t\\t\\tfloat s=length(xy-d0)/totalLen;\\n\\t\\t\\t\\tvec2 uv=xy/resolution;\\n\\n\\t\\t\\t\\tfloat d = getDepth(uv);\\n\\t\\t\\t\\tfloat vZ = getViewZ( d );\\n\\t\\t\\t\\tif(-vZ>=cameraFar) continue;\\n\\t\\t\\t\\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\\n\\t\\t\\t\\tvec3 vP=getViewPosition( uv, d, cW );\\n\\n\\t\\t\\t\\t#ifdef isPerspectiveCamera\\n\\t\\t\\t\\t\\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\\n\\t\\t\\t\\t\\tfloat recipVPZ=1./viewPosition.z;\\n\\t\\t\\t\\t\\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\\n\\t\\t\\t\\t\\tfloat sD=surfDist*cW;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\\n\\t\\t\\t\\t\\tfloat sD=surfDist;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tif(viewReflectRayZ-sD>vZ) continue;\\n\\n\\t\\t\\t\\t#ifdef isInfiniteThick\\n\\t\\t\\t\\t\\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\\n\\n\\t\\t\\t\\tfloat op=opacity;\\n\\n\\t\\t\\t\\tif(away<sD){\\n\\t\\t\\t\\t\\tvec3 vN=getViewNormal( uv );\\n\\t\\t\\t\\t\\tif(dot(viewReflectDir,vN)>=0.) continue;\\n\\t\\t\\t\\t\\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\\n\\t\\t\\t\\t\\tif(distance>maxDistance) break;\\n\\t\\t\\t\\t\\t#ifdef isDistanceAttenuation\\n\\t\\t\\t\\t\\t\\tfloat ratio=1.-(distance/maxDistance);\\n\\t\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\t#ifdef isFresnel\\n\\t\\t\\t\\t\\t\\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\\n\\t\\t\\t\\t\\t\\top*=fresnel;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tvec4 reflectColor=texture2D(tDiffuse,uv);\\n\\t\\t\\t\\t\\tgl_FragColor.xyz=reflectColor.xyz;\\n\\t\\t\\t\\t\\tgl_FragColor.a=op;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\"},n=exports.SSRDepthShader={defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:\"\\n\\n    varying vec2 vUv;\\n\\n    void main() {\\n\\n    \\tvUv = uv;\\n    \\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n    }\\n\\n  \",fragmentShader:\"\\n\\n    uniform sampler2D tDepth;\\n\\n    uniform float cameraNear;\\n    uniform float cameraFar;\\n\\n    varying vec2 vUv;\\n\\n    #include <packing>\\n\\n\\t\\tfloat getLinearDepth( const in vec2 uv ) {\\n\\n\\t\\t\\t#if PERSPECTIVE_CAMERA == 1\\n\\n\\t\\t\\t\\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\\n\\t\\t\\t\\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\\n\\t\\t\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t}\\n\\n    void main() {\\n\\n    \\tfloat depth = getLinearDepth( vUv );\\n\\t\\t\\tfloat d = 1.0 - depth;\\n\\t\\t\\t// d=(d-.999)*1000.;\\n    \\tgl_FragColor = vec4( vec3( d ), 1.0 );\\n\\n    }\\n\\n  \"},i=exports.SSRBlurShader={uniforms:{tDiffuse:{value:null},resolution:{value:new t.Vector2},opacity:{value:.5}},vertexShader:\"\\n\\n    varying vec2 vUv;\\n\\n    void main() {\\n\\n    \\tvUv = uv;\\n    \\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n    }\\n\\n  \",fragmentShader:\"\\n\\n    uniform sampler2D tDiffuse;\\n    uniform vec2 resolution;\\n    varying vec2 vUv;\\n    void main() {\\n\\t\\t\\t//reverse engineering from PhotoShop blur filter, then change coefficient\\n\\n    \\tvec2 texelSize = ( 1.0 / resolution );\\n\\n\\t\\t\\tvec4 c=texture2D(tDiffuse,vUv);\\n\\n\\t\\t\\tvec2 offset;\\n\\n\\t\\t\\toffset=(vec2(-1,0))*texelSize;\\n\\t\\t\\tvec4 cl=texture2D(tDiffuse,vUv+offset);\\n\\n\\t\\t\\toffset=(vec2(1,0))*texelSize;\\n\\t\\t\\tvec4 cr=texture2D(tDiffuse,vUv+offset);\\n\\n\\t\\t\\toffset=(vec2(0,-1))*texelSize;\\n\\t\\t\\tvec4 cb=texture2D(tDiffuse,vUv+offset);\\n\\n\\t\\t\\toffset=(vec2(0,1))*texelSize;\\n\\t\\t\\tvec4 ct=texture2D(tDiffuse,vUv+offset);\\n\\n\\t\\t\\t// float coeCenter=.5;\\n\\t\\t\\t// float coeSide=.125;\\n\\t\\t\\tfloat coeCenter=.2;\\n\\t\\t\\tfloat coeSide=.2;\\n\\t\\t\\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\\n\\t\\t\\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\\n\\t\\t\\tgl_FragColor=vec4(rgb,a);\\n\\n\\t\\t}\\n\\t\"};"},"sourceMaps":{"js":{"mappings":[{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":0}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":13}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":20}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":35}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":43}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":56}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":57}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":64}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":68}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":76}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":86}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":94}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":109}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":117}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":377,"column":1},"generated":{"line":1,"column":136}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":1,"column":0},"generated":{"line":1,"column":138}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"_three","original":{"line":1,"column":0},"generated":{"line":1,"column":142}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"require","original":{"line":1,"column":0},"generated":{"line":1,"column":144}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":1,"column":0},"generated":{"line":1,"column":152}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":8,"column":0},"generated":{"line":1,"column":161}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRShader","original":{"line":8,"column":6},"generated":{"line":1,"column":167}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"exports","original":{"line":8,"column":15},"generated":{"line":1,"column":169}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRShader","original":{"line":8,"column":15},"generated":{"line":1,"column":177}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":8,"column":18},"generated":{"line":1,"column":187}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"defines","original":{"line":9,"column":2},"generated":{"line":1,"column":188}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":9,"column":11},"generated":{"line":1,"column":196}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"MAX_STEP","original":{"line":10,"column":4},"generated":{"line":1,"column":197}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":10,"column":14},"generated":{"line":1,"column":206}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"isPerspectiveCamera","original":{"line":11,"column":4},"generated":{"line":1,"column":208}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":11,"column":25},"generated":{"line":1,"column":229}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"isDistanceAttenuation","original":{"line":12,"column":4},"generated":{"line":1,"column":231}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":12,"column":27},"generated":{"line":1,"column":254}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"isFresnel","original":{"line":13,"column":4},"generated":{"line":1,"column":256}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":13,"column":15},"generated":{"line":1,"column":267}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"isInfiniteThick","original":{"line":14,"column":4},"generated":{"line":1,"column":269}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":14,"column":21},"generated":{"line":1,"column":286}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"isSelective","original":{"line":15,"column":4},"generated":{"line":1,"column":288}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":15,"column":17},"generated":{"line":1,"column":301}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"uniforms","original":{"line":17,"column":2},"generated":{"line":1,"column":304}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":17,"column":12},"generated":{"line":1,"column":313}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tDiffuse","original":{"line":18,"column":4},"generated":{"line":1,"column":314}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":18,"column":14},"generated":{"line":1,"column":323}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":19,"column":6},"generated":{"line":1,"column":324}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":19,"column":13},"generated":{"line":1,"column":330}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tNormal","original":{"line":21,"column":4},"generated":{"line":1,"column":336}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":21,"column":13},"generated":{"line":1,"column":344}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":22,"column":6},"generated":{"line":1,"column":345}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":22,"column":13},"generated":{"line":1,"column":351}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tMetalness","original":{"line":24,"column":4},"generated":{"line":1,"column":357}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":24,"column":16},"generated":{"line":1,"column":368}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":25,"column":6},"generated":{"line":1,"column":369}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":25,"column":13},"generated":{"line":1,"column":375}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tDepth","original":{"line":27,"column":4},"generated":{"line":1,"column":381}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":27,"column":12},"generated":{"line":1,"column":388}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":28,"column":6},"generated":{"line":1,"column":389}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":28,"column":13},"generated":{"line":1,"column":395}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraNear","original":{"line":30,"column":4},"generated":{"line":1,"column":401}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":30,"column":16},"generated":{"line":1,"column":412}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":31,"column":6},"generated":{"line":1,"column":413}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":31,"column":13},"generated":{"line":1,"column":419}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraFar","original":{"line":33,"column":4},"generated":{"line":1,"column":425}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":33,"column":15},"generated":{"line":1,"column":435}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":34,"column":6},"generated":{"line":1,"column":436}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":34,"column":13},"generated":{"line":1,"column":442}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"resolution","original":{"line":36,"column":4},"generated":{"line":1,"column":448}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":36,"column":16},"generated":{"line":1,"column":459}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":37,"column":6},"generated":{"line":1,"column":460}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":37,"column":13},"generated":{"line":1,"column":466}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"Vector2","original":{"line":37,"column":17},"generated":{"line":1,"column":470}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":37,"column":24},"generated":{"line":1,"column":472}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraProjectionMatrix","original":{"line":39,"column":4},"generated":{"line":1,"column":481}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":39,"column":28},"generated":{"line":1,"column":504}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":40,"column":6},"generated":{"line":1,"column":505}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":40,"column":13},"generated":{"line":1,"column":511}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"Matrix4","original":{"line":40,"column":17},"generated":{"line":1,"column":515}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":40,"column":24},"generated":{"line":1,"column":517}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraInverseProjectionMatrix","original":{"line":42,"column":4},"generated":{"line":1,"column":526}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":42,"column":35},"generated":{"line":1,"column":556}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":43,"column":6},"generated":{"line":1,"column":557}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":43,"column":13},"generated":{"line":1,"column":563}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"Matrix4","original":{"line":43,"column":17},"generated":{"line":1,"column":567}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":43,"column":24},"generated":{"line":1,"column":569}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"opacity","original":{"line":45,"column":4},"generated":{"line":1,"column":578}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":45,"column":13},"generated":{"line":1,"column":586}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":46,"column":6},"generated":{"line":1,"column":587}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":46,"column":13},"generated":{"line":1,"column":593}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"maxDistance","original":{"line":48,"column":4},"generated":{"line":1,"column":597}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":48,"column":17},"generated":{"line":1,"column":609}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":49,"column":6},"generated":{"line":1,"column":610}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":49,"column":13},"generated":{"line":1,"column":616}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraRange","original":{"line":51,"column":4},"generated":{"line":1,"column":621}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":51,"column":17},"generated":{"line":1,"column":633}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":52,"column":6},"generated":{"line":1,"column":634}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":52,"column":13},"generated":{"line":1,"column":640}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"surfDist","original":{"line":54,"column":4},"generated":{"line":1,"column":643}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":54,"column":14},"generated":{"line":1,"column":652}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":55,"column":6},"generated":{"line":1,"column":653}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":55,"column":13},"generated":{"line":1,"column":659}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"thickTolerance","original":{"line":57,"column":4},"generated":{"line":1,"column":665}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":57,"column":20},"generated":{"line":1,"column":680}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":58,"column":6},"generated":{"line":1,"column":681}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":58,"column":13},"generated":{"line":1,"column":687}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"vertexShader","original":{"line":61,"column":2},"generated":{"line":1,"column":693}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":63,"column":2},"generated":{"line":1,"column":706}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"fragmentShader","original":{"line":76,"column":2},"generated":{"line":1,"column":872}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":78,"column":2},"generated":{"line":1,"column":887}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRDepthShader","original":{"line":244,"column":6},"generated":{"line":1,"column":7133}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"exports","original":{"line":244,"column":20},"generated":{"line":1,"column":7135}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRDepthShader","original":{"line":244,"column":20},"generated":{"line":1,"column":7143}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":244,"column":23},"generated":{"line":1,"column":7158}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"defines","original":{"line":245,"column":2},"generated":{"line":1,"column":7159}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":245,"column":11},"generated":{"line":1,"column":7167}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"PERSPECTIVE_CAMERA","original":{"line":246,"column":4},"generated":{"line":1,"column":7168}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":246,"column":24},"generated":{"line":1,"column":7187}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"uniforms","original":{"line":248,"column":2},"generated":{"line":1,"column":7190}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":248,"column":12},"generated":{"line":1,"column":7199}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tDepth","original":{"line":249,"column":4},"generated":{"line":1,"column":7200}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":249,"column":12},"generated":{"line":1,"column":7207}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":250,"column":6},"generated":{"line":1,"column":7208}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":250,"column":13},"generated":{"line":1,"column":7214}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraNear","original":{"line":252,"column":4},"generated":{"line":1,"column":7220}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":252,"column":16},"generated":{"line":1,"column":7231}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":253,"column":6},"generated":{"line":1,"column":7232}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":253,"column":13},"generated":{"line":1,"column":7238}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"cameraFar","original":{"line":255,"column":4},"generated":{"line":1,"column":7244}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":255,"column":15},"generated":{"line":1,"column":7254}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":256,"column":6},"generated":{"line":1,"column":7255}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":256,"column":13},"generated":{"line":1,"column":7261}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"vertexShader","original":{"line":259,"column":2},"generated":{"line":1,"column":7268}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":261,"column":2},"generated":{"line":1,"column":7281}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"fragmentShader","original":{"line":273,"column":2},"generated":{"line":1,"column":7445}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":275,"column":2},"generated":{"line":1,"column":7460}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRBlurShader","original":{"line":313,"column":6},"generated":{"line":1,"column":8185}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"exports","original":{"line":313,"column":19},"generated":{"line":1,"column":8187}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"SSRBlurShader","original":{"line":313,"column":19},"generated":{"line":1,"column":8195}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":313,"column":22},"generated":{"line":1,"column":8209}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"uniforms","original":{"line":314,"column":2},"generated":{"line":1,"column":8210}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":314,"column":12},"generated":{"line":1,"column":8219}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"tDiffuse","original":{"line":315,"column":4},"generated":{"line":1,"column":8220}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":315,"column":14},"generated":{"line":1,"column":8229}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":316,"column":6},"generated":{"line":1,"column":8230}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":316,"column":13},"generated":{"line":1,"column":8236}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"resolution","original":{"line":318,"column":4},"generated":{"line":1,"column":8242}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":318,"column":16},"generated":{"line":1,"column":8253}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":319,"column":6},"generated":{"line":1,"column":8254}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":319,"column":13},"generated":{"line":1,"column":8260}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"Vector2","original":{"line":319,"column":17},"generated":{"line":1,"column":8264}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":319,"column":24},"generated":{"line":1,"column":8266}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"opacity","original":{"line":321,"column":4},"generated":{"line":1,"column":8275}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":321,"column":13},"generated":{"line":1,"column":8283}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"value","original":{"line":322,"column":6},"generated":{"line":1,"column":8284}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":322,"column":13},"generated":{"line":1,"column":8290}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"vertexShader","original":{"line":325,"column":2},"generated":{"line":1,"column":8295}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":327,"column":2},"generated":{"line":1,"column":8308}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","name":"fragmentShader","original":{"line":339,"column":2},"generated":{"line":1,"column":8472}},{"source":"node_modules/three-stdlib/shaders/SSRShader.js","original":{"line":341,"column":2},"generated":{"line":1,"column":8487}}],"sources":{"node_modules/three-stdlib/shaders/SSRShader.js":"import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html\n */\n\nconst SSRShader = {\n  defines: {\n    MAX_STEP: 0,\n    isPerspectiveCamera: true,\n    isDistanceAttenuation: true,\n    isFresnel: true,\n    isInfiniteThick: false,\n    isSelective: false\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tMetalness: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    opacity: {\n      value: 0.5\n    },\n    maxDistance: {\n      value: 180\n    },\n    cameraRange: {\n      value: 0\n    },\n    surfDist: {\n      value: 0.007\n    },\n    thickTolerance: {\n      value: 0.03\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float surfDist;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\tuniform float thickTolerance;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef isSelective\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tvec3 viewIncidenceDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidenceDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<MAX_STEP;i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\t\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t\tfloat sD=surfDist*cW;\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t\tfloat sD=surfDist;\n\t\t\t\t#endif\n\t\t\t\tif(viewReflectRayZ-sD>vZ) continue;\n\n\t\t\t\t#ifdef isInfiniteThick\n\t\t\t\t\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\n\t\t\t\t#endif\n\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\tfloat op=opacity;\n\n\t\t\t\tif(away<sD){\n\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef isFresnel\n\t\t\t\t\t\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\top*=fresnel;\n\t\t\t\t\t#endif\n\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n};\nconst SSRDepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n    \tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n    }\n\n  `\n};\nconst SSRBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    opacity: {\n      value: 0.5\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n    void main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t`\n};\n\nexport { SSRBlurShader, SSRDepthShader, SSRShader };\n"},"lineCount":null}},"error":null,"hash":"ebcd90eab5a141e460f7839cd28a4066","cacheData":{"env":{}}}